{"version":3,"file":"bundle.min.js","sources":["../src/js/components/vie.js","../src/js/components/score.js","../src/js/components/ball.js","../src/js/components/classBarre.js","../src/js/components/particle.js","../src/js/components/bloc.js","../src/js/components/particleManager.js","../src/js/components/grid.js","../src/js/index.js","../src/js/components/gameUI.js"],"sourcesContent":["/**\n * Gestion des vies du joueur\n * Gère le compteur de vies et l'affichage\n *\n * @export\n * @class Vie\n */\n\nexport default class Vie {\n\n  /**\n   * Crée une instance de Vie\n   *\n   * @constructor\n   * @param {number} [nbVie=3] - Nombre de vies initial\n   */\n  constructor(nbVie = 3) {\n    this.vie = nbVie;\n  };\n\n  /**\n   * Décrémente le nombre de vies\n   * Affiche \"GAME OVER\" si les vies atteignent 0\n   *\n   * @returns {void}\n   */\n  loose() {\n    this.vie--;\n    if (this.vie === 0) {\n      alert(\"GAME OVER\"); // a remplacer par un event gameui\n    };\n  };\n\n  /**\n   * Dessine le compteur de vies sur le canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx){ //param : canva\n    ctx.font = \"16px Arial\";\n    ctx.fillStyle = \"#0095DD\";\n    ctx.fillText(`Lives: ${this.vie}`, ctx.canvas.width-65, 20);\n    }\n  }\n","/**\n * Gestion du score du jeu\n * Gère l'incrémentation et l'affichage du score\n *\n * @export\n * @class Score\n */\n\nexport default class Score {\n\n  /**\n   * Crée une instance de Score\n   *\n   * @constructor\n   */\n  constructor(){\n    this.score=0;\n  }\n\n  /**\n   * Incrémente le score de 1 point\n   *\n   * @returns {void}\n   */\n  scoreUp() {\n    this.score += 1;\n    /*if (score == brickRowCount * brickColumnCount) {\n      alert(\"YOU WIN, CONGRATS!\");\n      document.location.reload();\n    }*/\n  }\n\n  /**\n   * Dessine le score sur le canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx){  //param : canva\n    ctx.font = \"16px Arial\";\n    ctx.fillStyle = \"#0095DD\";\n    ctx.fillText(`Score: ${this.score}`, 280, 20);\n  }\n}","import Vie from \"./vie.js\";\n\n/**\n * Balle du jeu Casse-Brique\n * Gère le mouvement, les collisions et l'affichage de la balle\n *\n * @class Ball\n */\nclass Ball {\n  /**\n   * Crée une instance de Ball\n   *\n   * @constructor\n   * @param {number} x - Position initiale en X (abscisse)\n   * @param {number} y - Position initiale en Y (ordonnée)\n   * @param {number} radius - Rayon de la balle en pixels\n   * @param {string} [color=\"blue\"] - Couleur de la balle\n   */\n  constructor(x, y, radius, color = \"blue\") {\n    this.x = x; // Position de X\n    this.y = y; // Position de Y\n    if (radius < 10) {\n      this.radius = 10;\n    } else {\n      this.radius = radius;\n    }\n    // Rayon\n    this.color = color; // Couleur\n    // Vitesses par défaut\n    this.dx = 2; // Vitesse horizontale\n    this.dy = -2; // Vitesse verticale\n  }\n\n  /**\n   * Dessine la balle sur le canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx) {\n    ctx.beginPath(); // Début d dessin\n    ctx.fillStyle = this.color; // on choisi la couleur qu'on a defini avant\n    ctx.arc(\n      this.x, // Coordonnée de X\n      this.y, // Coordonnée de Y\n      this.radius, // le Rayon\n      0, // Début de l'angle\n      Math.PI * 2 // Fin de l'angle\n    );\n    ctx.fill(); // Remplissage du cercle\n    ctx.closePath(); // Fin du dessin\n  }\n\n  /**\n   * Gère le mouvement de la balle et toutes ses collisions\n   * Vérifie les collisions avec les murs, la barre, le sol et les blocs\n   *\n   * @param {HTMLCanvasElement} canvas - Canvas HTML pour les limites du jeu\n   * @param {Object} livesObj - Objet contenant le nombre de vies (propriété lives)\n   * @param {Object} paddle - Objet barre avec propriétés paddleX, paddleWidth, paddleHeight\n   * @param {Object} grid - Grille de briques avec propriétés rowCount, columnCount, bricks\n   * @param {Object} score - Objet score avec méthode scoreUp()\n   * @returns {void}\n   */\n  move(canvas, livesObj, paddle, grid, score) {\n    // quand sa touche les murs sur les cotés\n    if (\n      this.x + this.dx > canvas.width - this.radius ||\n      this.x + this.dx < this.radius\n    ) {\n      this.dx = -this.dx;\n    }\n\n    // quand sa touche le mur du haut\n    if (this.y + this.dy < this.radius) {\n      this.dy = -this.dy;\n    }\n\n    // Collision avec la barre\n    else if (\n      this.y + this.dy > canvas.height - this.radius - paddle.paddleHeight &&\n      this.x > paddle.paddleX &&\n      this.x < paddle.paddleX + paddle.paddleWidth\n    ) {\n      this.dy = -this.dy;\n    }\n    // quand sa touche le sol\n    else if (this.y + this.dy > canvas.height - this.radius) {\n      livesObj.loose();\n\n      if (livesObj.lives <= 0) {\n        this.x = canvas.width / 2;\n        this.y = canvas.height - 30;\n        this.dx = 2;\n        this.dy = -2;\n        paddle.paddleX = (canvas.width - paddle.paddleWidth) / 2;\n      } else {\n        this.x = canvas.width / 2;\n        this.y = canvas.height - 30;\n        this.dx = 2;\n        this.dy = -2;\n        paddle.paddleX = (canvas.width - paddle.paddleWidth) / 2;\n      }\n    }\n\n    // Collision avec les blocs\n    for (let r = 0; r < grid.rowCount; r++) {\n      for (let c = 0; c < grid.columnCount; c++) {\n        let b = grid.bricks[r][c];\n        if (b.status == 1) {\n          if (\n            this.x > b.x &&\n            this.x < b.x + b.width &&\n            this.y > b.y &&\n            this.y < b.y + b.height\n          ) {\n            this.dy = -this.dy;\n            // --- NOUVELLE LOGIQUE ---\n            // On demande au bloc de recevoir le coup.\n            // La méthode retourne TRUE si le bloc est détruit, FALSE sinon.\n            const estDetruit = b.recevoirCoup();\n\n            // On n'augmente le score QUE si le bloc est réellement détruit\n            if (estDetruit) {\n              score.scoreUp();\n            }\n          }\n        }\n      }\n    }\n\n    this.x += this.dx;\n    this.y += this.dy;\n  }\n}\n\nexport default Ball;\n","/**\n * Barre de contrôle du joueur (paddle)\n * Gère le déplacement et l'affichage de la barre contrôlée par clavier ou souris\n *\n * @class Barre\n */\nclass Barre {\n  /**\n   * Crée une instance de Barre\n   *\n   * @constructor\n   * @param {HTMLCanvasElement} canvas - Canvas HTML pour le rendu et la détection des limites\n   * @param {number} [paddleHeight=10] - Hauteur de la barre en pixels\n   * @param {number} [paddleWidth=75] - Largeur de la barre en pixels\n   */\n  constructor(canvas, paddleHeight = 10, paddleWidth = (canvas.width / 15)) {\n    this.canvas = canvas;\n    this.ctx = this.canvas.getContext(\"2d\");\n\n    // Paramètres barre\n    if (paddleWidth < 75) {\n      this.paddleWidth = 75;\n    } else{\n        this.paddleWidth = paddleWidth;\n    }\n    this.paddleHeight = paddleHeight;\n    this.paddleX = (canvas.width - paddleWidth) / 2;\n\n    // Déplacement\n    this.rightPressed = false;\n    this.leftPressed = false;\n\n    // Bind des handlers\n    this.keyDownHandler = this.keyDownHandler.bind(this);\n    this.keyUpHandler = this.keyUpHandler.bind(this);\n    this.mouseMoveHandler = this.mouseMoveHandler.bind(this);\n\n    // Écouteurs\n    document.addEventListener(\"keydown\", this.keyDownHandler);\n    document.addEventListener(\"keyup\", this.keyUpHandler);\n    document.addEventListener(\"mousemove\", this.mouseMoveHandler);\n  }\n\n    /**\n     * Gère l'appui sur une touche du clavier\n     * Détecte les flèches gauche/droite et déplace la barre\n     *\n     * @param {KeyboardEvent} e - Événement clavier\n     * @returns {void}\n     */\n    keyDownHandler(e) {\n        if (e.key === \"Right\" || e.key === \"ArrowRight\") {\n            this.rightPressed = true; // JUSTE ÇA. Pas de mouvement ici !\n        } else if (e.key === \"Left\" || e.key === \"ArrowLeft\") {\n            this.leftPressed = true;  // JUSTE ÇA.\n        }\n    }\n\n    /**\n     * Gère le relâchement d'une touche du clavier\n     * Arrête le déplacement de la barre\n     *\n     * @param {KeyboardEvent} e - Événement clavier\n     * @returns {void}\n     */\n    keyUpHandler(e) {\n        if (e.key === \"Right\" || e.key === \"ArrowRight\") {\n            this.rightPressed = false;\n        } else if (e.key === \"Left\" || e.key === \"ArrowLeft\") {\n            this.leftPressed = false;\n        }\n    }\n\n    // Cette fonction est appelée 60 fois par seconde automatiquement\n    deplacerLaRaquette() {\n        // On vérifie l'état des interrupteurs\n        if (this.rightPressed) {\n            // On vérifie les murs ICI\n            if (this.paddleX < this.canvas.width - this.paddleWidth) {\n                this.paddleX += 4; // Vitesse constante et FLUIDE\n            }\n        }\n        else if (this.leftPressed) {\n            // On vérifie les murs ICI\n            if (this.paddleX > 0) {\n                this.paddleX -= 4; // Vitesse constante et FLUIDE\n            }\n        }\n    }\n    /**\n     * Gère le mouvement de la souris\n     * Déplace la barre pour suivre la position horizontale de la souris\n     *\n     * @param {MouseEvent} e - Événement souris\n     * @returns {void}\n     */\n    mouseMoveHandler(e) {\n        const relativeX = e.clientX - this.canvas.offsetLeft;\n        if (relativeX > 0 && relativeX < this.canvas.width) {\n            this.paddleX = relativeX - this.paddleWidth / 2;\n        }\n    }\n\n  /**\n   * Dessine la barre sur le canvas\n   *\n   * @returns {void}\n   */\n  drawPaddle() {\n    this.ctx.beginPath();\n    this.ctx.rect(\n      this.paddleX,\n      this.canvas.height - this.paddleHeight, // ✔️ Correction ici\n      this.paddleWidth,\n      this.paddleHeight\n    );\n    this.ctx.fillStyle = \"#0095DD\";\n    this.ctx.fill();\n    this.ctx.closePath();\n  }\n}\n\nexport default Barre;\n","/**\n * Particule d'explosion pour l'animation de destruction des blocs\n * Représente une particule avec position, vélocité et durée de vie\n *\n * @class Particle\n */\nexport default class Particle {\n  /**\n   * Crée une instance de Particle\n   *\n   * @constructor\n   * @param {number} x - Position X initiale\n   * @param {number} y - Position Y initiale\n   * @param {string} color - Couleur de la particule\n   */\n  constructor(x, y, color) {\n    this.x = x;\n    this.y = y;\n    this.vx = (Math.random() - 0.5) * 12;\n    this.vy = (Math.random() - 0.5) * 12;\n    this.color = color;\n    this.life = 1.0;\n    this.decay = 0.02;\n    this.size = Math.random() * 12 + 12;\n    this.rotation = Math.random() * Math.PI * 2;\n    this.rotationSpeed = (Math.random() - 0.5) * 0.2;\n  }\n\n  /**\n   * Met à jour la position et la durée de vie de la particule\n   *\n   * @returns {boolean} true si la particule est encore active, false sinon\n   */\n  update() {\n    this.x += this.vx;\n    this.y += this.vy;\n    this.vy += 0.05;\n    this.life -= this.decay;\n    this.rotation += this.rotationSpeed;\n    return this.life > 0;\n  }\n\n  /**\n   * Dessine la particule sur le canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx) {\n    ctx.save();\n    ctx.globalAlpha = this.life;\n    ctx.translate(this.x + this.size/2, this.y + this.size/2);\n    ctx.rotate(this.rotation);\n    \n    // Ombre\n    ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';\n    ctx.shadowBlur = 5;\n    ctx.shadowOffsetX = 2;\n    ctx.shadowOffsetY = 2;\n    \n    ctx.fillStyle = this.color;\n    ctx.fillRect(-this.size/2, -this.size/2, this.size, this.size);\n    ctx.restore();\n  }\n}","import ParticleManager from \"./particleManager.js\";\n\n// Instance globale du gestionnaire de particules\nexport const particleManager = new ParticleManager();\n\n/**\n * Brique individuelle du jeu Casse-Brique\n * Représente une brique avec sa position, taille, couleur et état\n *\n * @class Bloc\n */\nexport class Bloc {\n\n  /**\n   * Crée une instance de Bloc\n   *\n   * @constructor\n   * @param {number} x - Position horizontale (abscisse) en pixels\n   * @param {number} y - Position verticale (ordonnée) en pixels\n   * @param {number} width - Largeur de la brique en pixels\n   * @param {number} height - Hauteur de la brique en pixels\n   * @param {string} [color=\"grey\"] - Couleur de la brique\n   * @param {number} [status=1] - État de la brique (nombre de hits restants)\n   * @param {number} [maxHits=1] - Nombre maximum de hits nécessaires pour détruire la brique\n   */\n  constructor(x, y, width, height, color=\"grey\", status = 1, maxHits = null){\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    this.color = color;\n    this.status = status;\n    this.maxHits = maxHits || this.getMaxHitsByColor(color);\n  }\n\n  /**\n   * Détermine le nombre de hits nécessaires selon la couleur\n   *\n   * @private\n   * @param {string} color - Couleur de la brique\n   * @returns {number} Nombre de hits nécessaires\n   */\n  getMaxHitsByColor(color) {\n    switch(color.toLowerCase()) {\n      case 'blue':\n        return 2;\n      default:\n        return 1;\n    }\n  }\n\n  /**\n   * Gère la collision avec la brique\n   *\n   * @returns {boolean} true si la brique est détruite, false sinon\n   */\n  hit() {\n    if (this.status <= 0) {\n      return true;\n    }\n    \n    this.status--;\n    return this.status <= 0;\n  }\n\n  /**\n   * Dessine la brique sur le canvas si elle est active\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx) {\n    // Dessiner la brique si elle est active (status > 0)\n    if (this.status > 0) {\n      ctx.beginPath();\n      \n      ctx.fillStyle = this.color;\n      ctx.rect(this.x, this.y, this.width, this.height);\n      ctx.fill();\n      ctx.closePath();\n      \n      // Réinitialiser l'opacité\n      ctx.globalAlpha = 1.0;\n      \n      // Afficher le nombre de hits restants pour les blocs multihit\n      if (this.maxHits > 1 && this.status > 1) {\n        ctx.fillStyle = 'white';\n        ctx.font = '12px Arial';\n        ctx.textAlign = 'center';\n        ctx.textBaseline = 'middle';\n        ctx.fillText(this.status.toString(), this.x + this.width/2, this.y + this.height/2);\n      }\n    }\n  }\n\n  recevoirCoup(){\n    if (this.status > 0) {\n      // Créer directement les particules d'explosion\n      particleManager.createExplosion(\n        this.x + this.width / 2,\n        this.y + this.height / 2,\n        this.color,\n        20\n      );\n    }\n    this.status = 0;\n    return true;\n  }\n}\n\nexport class BlocDur extends Bloc{\n    /**\n   * @param {number} vie - Nombre de coups nécessaires\n   */\n  constructor(x, y, width, height, color = \"blue\", vie = 3) {\n    // 1. On appelle le constructeur du parent avec super()\n    super(x, y, width, height, color); \n    \n    // 2. On ajoute la propriété spécifique\n    this.vie = vie;\n    this.vieMax = vie; // Pour calculer la couleur (optionnel)\n  }\n\n  // Surcharge de la méthode de collision\n  recevoirCoup() {\n    this.vie--;\n\n    // Changement visuel pour montrer les dégâts (s'assombrit)\n    this.color = this.vie === 1 ? \"red\" : \"orange\";\n\n    if (this.vie <= 0) {\n      // Créer directement les particules d'explosion\n      particleManager.createExplosion(\n        this.x + this.width / 2,\n        this.y + this.height / 2,\n        this.color,\n        20\n      );\n      this.status = 0;\n      return true; // Détruit\n    }\n    return false; // Pas encore détruit\n  }\n}","import Particle from \"./particle.js\";\n\n/**\n * Gestionnaire d'animations de particules\n * Centralise la gestion de toutes les particules actives\n *\n * @class ParticleManager\n */\nexport default class ParticleManager {\n  constructor() {\n    this.particles = [];\n  }\n\n  /**\n   * Ajoute une explosion de particules à une position donnée\n   *\n   * @param {number} x - Position X de l'explosion\n   * @param {number} y - Position Y de l'explosion\n   * @param {string} color - Couleur des particules\n   * @param {number} count - Nombre de particules à générer\n   * @returns {void}\n   */\n  createExplosion(x, y, color, count = 15) {\n    for (let i = 0; i < count; i++) {\n      this.particles.push(new Particle(x, y, color));\n    }\n  }\n\n  /**\n   * Met à jour toutes les particules et retire celles qui sont terminées\n   *\n   * @returns {void}\n   */\n  update() {\n    this.particles = this.particles.filter(particle => particle.update());\n  }\n\n  /**\n   * Dessine toutes les particules actives\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx) {\n    this.particles.forEach(particle => particle.draw(ctx));\n  }\n\n  /**\n   * Vérifie s'il y a des particules actives\n   *\n   * @returns {boolean} true s'il y a des particules actives\n   */\n  hasActiveParticles() {\n    return this.particles.length > 0;\n  }\n}","import { Bloc, BlocDur } from \"./bloc.js\";\n\n/**\n * Grille de briques pour le jeu Casse-Brique\n * Gère la création, l'organisation et l'affichage de la grille de blocs\n *\n * @export\n * @class Grid\n */\nexport default class Grid {\n  /**\n   * Crée une instance de Grid\n   *\n   * @constructor\n   * @param {number} columnCount - Nombre de colonnes de briques\n   * @param {number} rowCount - Nombre de lignes de briques\n   * @param {number} width - Largeur d'une brique en pixels\n   * @param {number} height - Hauteur d'une brique en pixels\n   * @param {number} padding - Espacement entre les briques en pixels\n   * @param {number} offsetTop - Marge supérieure de la grille en pixels\n   * @param {HTMLCanvasElement} canvas - Canvas HTML pour le rendu\n   */\n  constructor(\n    columnCount,\n    rowCount,\n    width,\n    height,\n    padding,\n    offsetTop,\n    canvas\n  ) {\n    // --- PARAMÈTRES transmis---\n    this.columnCount = columnCount; // nombre de colonnes\n    this.rowCount = rowCount; // nombre de lignes\n    this.width = width; // largeur d'une brique\n    this.height = height; // hauteur d'une brique\n    this.padding = padding; // espace entre les briques\n    this.offsetTop = offsetTop; // marge haute de la grille\n    this.canvas = canvas; // canvas envoyé depuis le HTML\n\n    // Tableau de briques, à vide.\n    this.bricks = [];\n\n    // Construction de la grille\n    this.initializeBricks();\n  }\n\n  /**\n   \nRecalcule la taille et la position des briques existantes\n@param {number} newWidth - Nouvelle largeur d'une brique\n@param {number} newHeight - Nouvelle hauteur d'une brique*/\n  resize(newWidth, newHeight) {\n    this.width = newWidth;\n    this.height = newHeight;\n\n    // Recalcul du centrage horizontal\n    const totalGridWidth =\n      this.columnCount * this.width + (this.columnCount - 1) * this.padding;\n    const offsetLeft = (this.canvas.width - totalGridWidth) / 2;\n\n    // Mise à jour de chaque brique\n    for (let row = 0; row < this.rowCount; row++) {\n      for (let col = 0; col < this.columnCount; col++) {\n        const b = this.bricks[row][col];\n        // On ne met à jour que si la brique existe\n        if (b) {\n          b.width = this.width;\n          b.height = this.height;\n          b.x = offsetLeft + col * (this.width + this.padding);\n          b.y = this.offsetTop + row * (this.height + this.padding);\n        }\n      }\n    }\n  }\n\n  /**\n   * Initialise le tableau de briques avec leurs positions\n   * Calcule automatiquement les positions pour centrer la grille horizontalement\n   *\n   * @returns {void}\n   */\n  initializeBricks() {\n    // Largeur totale de la grille\n    const totalGridWidth =\n      this.columnCount * this.width + (this.columnCount - 1) * this.padding;\n\n    // Centrage horizontal PARFAIT\n    const offsetLeft = (this.canvas.width - totalGridWidth) / 2;\n\n    // Construction ligne par ligne\n    for (let row = 0; row < this.rowCount; row++) {\n      this.bricks[row] = [];\n\n      for (let col = 0; col < this.columnCount; col++) {\n        const x = offsetLeft + col * (this.width + this.padding);\n        const y = this.offsetTop + row * (this.height + this.padding);\n\n        // --- LOGIQUE DE GÉNÉRATION DES TYPES DE BRIQUES ---\n        let newBrick;\n\n        if (Math.random() < 0.2) {\n          // 10% de chance d'avoir un bloc dur (aléatoire)\n          newBrick = new BlocDur(x, y, this.width, this.height, \"blue\");\n        } else {\n          // Le reste : briques standard grises\n          newBrick = new Bloc(x, y, this.width, this.height, \"grey\");\n        }\n\n        // On stocke l'instance de la classe dans le tableau\n        this.bricks[row][col] = newBrick;\n      }\n    }\n  }\n\n  /**\n   * Retourne le tableau de briques\n   *\n   * @returns {Array<Array<Object>>} Tableau 2D des briques avec leurs propriétés\n   */\n  getBricks() {\n    return this.bricks;\n  }\n\n  /**\n   * Dessine toutes les briques actives sur le canvas\n   *\n   * @param {CanvasRenderingContext2D} ctx - Contexte de rendu 2D du canvas\n   * @returns {void}\n   */\n  draw(ctx) {\n    // On nettoie la zone d'affichage\n    //ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    this.bricks.forEach((row) => {\n      row.forEach((bloc) => {\n        // On utilise directement l'instance stockée !\n        // (Plus de \"new Bloc()\" ici, sinon on perdrait les PV des briques dures)\n        if (bloc.status !== 0) {\n          bloc.draw(ctx);\n        }\n      });\n    });\n  }\n}\n","import GameUI from \"./components/gameUI.js\";\n\n/**\n * Point d'entrée principal du jeu Casse-Brique\n * Initialise le canvas et lance la boucle de jeu\n */\n\n// Configuration du canvas\nconst canvas = /** @type {HTMLCanvasElement} */ (document.getElementById(\"canvaGame\"));\nconst ctx = canvas.getContext(\"2d\");\n\n// Taille du canvas\ncanvas.width = window.innerWidth;\ncanvas.height = window.innerHeight-100;\n\n// Initialisation du jeu\nconst gameUI = new GameUI(canvas, 3);\n\n\n/**\n * Boucle principale du jeu\n */\nfunction gameLoop() {\n  // Nettoyer le canvas\n  ctx.clearRect(0, 0, canvas.width, canvas.height);\n\n  // Dessiner les éléments du jeu\n  gameUI.draw();\n\n\n  // Continuer la boucle\n  requestAnimationFrame(gameLoop);\n}\n\n\n// D�marrer le jeu\ngameLoop();\n","import Vie from \"./vie.js\";\nimport Score from \"./score.js\";\nimport Ball from \"./ball.js\";\nimport Barre from \"./classBarre.js\";\nimport Grid from \"./grid.js\";\nimport { particleManager } from \"./bloc.js\";\n\n/**\n * Interface principale du jeu Casse-Brique\n * Gère l'initialisation et le rendu de tous les éléments du jeu\n *\n * @export\n * @class GameUI\n */\nexport default class GameUI {\n\n    /**\n     * Crée une instance de GameUI\n     *\n     * @constructor\n     * @param {HTMLCanvasElement} canvas - Le canvas HTML pour le rendu du jeu\n     * @param {number} nbVie - Nombre de vies initial (paramètre actuellement non utilisé)\n     */\n\n    constructor(canvas, nbVie /** @type {number} */){\n        const rowGrid= 6 // nombre de ligne de brique\n        const colGrid = 10 // nombre de colonne de brique\n        let radBall = canvas.width/70 \n        let largeBloc = (canvas.width-100)/colGrid // largeur d'une brique\n        let hautBloc = (canvas.height*0.5)/rowGrid // hauteur d'une brique\n        this.score = new Score(); // score\n        this.vie = new Vie(); // nombre de vies\n        this.ballList = []; // liste des balles (par défaut: ballList[0])\n        this.ballList.push(new Ball(300, 300, (canvas.width/70)));\n        this.canvas = canvas;\n        this.barre = new Barre(canvas);\n        this.grid = new Grid(10, 6, (this.canvas.width/11), (this.canvas.width/50), 10, 30, this.canvas);\n        window.addEventListener('resize', () => this.handleResize(colGrid, rowGrid));\n    }\n\n    handleResize(colGrid, rowGrid) {\n        // 1. Mettre à jour la taille du canvas\n        this.canvas.width = window.innerWidth;\n        this.canvas.height = window.innerHeight - 100;\n\n        // 2. Calculer les nouvelles dimensions des briques\n        // (On reprend la logique du constructeur : width  et height)\n        const newBrickWidth = (this.canvas.width - 100) / colGrid;\n        const newBrickHeight = (this.canvas.height * 0.5) / rowGrid;\n\n        // 3. Appliquer les changements à la grille\n        this.grid.resize(newBrickWidth, newBrickHeight);\n\n        // Optionnel : Recaler la barre au centre ou s'assurer qu'elle ne sort pas de l'écran\n        if (this.barre.paddleX > this.canvas.width - this.barre.paddleWidth) {\n            this.barre.paddleX = this.canvas.width - this.barre.paddleWidth;\n        }\n    }\n    \n    \n    /**\n     * Dessine tous les éléments du jeu sur le canvas\n     * Met à jour et affiche : balle, grille, vies, score, barre et particules\n     *\n     * @returns {void}\n     */\n    draw(){\n        let ctx = this.canvas.getContext(\"2d\");\n        \n        // Déplacer la balle\n        this.ballList[0].move(this.canvas, this.vie, this.barre, this.grid, this.score);\n        \n        // Mettre à jour les particules\n        particleManager.update();\n        \n        // Dessiner la balle\n        this.ballList[0].draw(ctx);\n        \n        // affiche grille\n        this.grid.draw(ctx);\n\n        // affiche particules (après la grille pour qu'elles apparaissent au-dessus)\n        particleManager.draw(ctx);\n\n        // affiche vie\n        this.vie.draw(ctx);\n\n        // affiche score\n        this.score.draw(ctx);\n\n        // affiche barre (paddle)\n        this.barre.drawPaddle();\n        this.barre.deplacerLaRaquette();\n\n    };\n    \n}"],"names":["Vie","constructor","nbVie","this","vie","loose","alert","draw","ctx","font","fillStyle","fillText","canvas","width","Score","score","scoreUp","Ball","x","y","radius","color","dx","dy","beginPath","arc","Math","PI","fill","closePath","move","livesObj","paddle","grid","height","paddleHeight","paddleX","paddleWidth","lives","r","rowCount","c","columnCount","b","bricks","status","recevoirCoup","Barre","getContext","rightPressed","leftPressed","keyDownHandler","bind","keyUpHandler","mouseMoveHandler","document","addEventListener","e","key","deplacerLaRaquette","relativeX","clientX","offsetLeft","drawPaddle","rect","Particle","vx","random","vy","life","decay","size","rotation","rotationSpeed","update","save","globalAlpha","translate","rotate","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","fillRect","restore","particleManager","particles","createExplosion","count","i","push","filter","particle","forEach","hasActiveParticles","length","Bloc","maxHits","getMaxHitsByColor","toLowerCase","hit","textAlign","textBaseline","toString","BlocDur","super","vieMax","Grid","padding","offsetTop","initializeBricks","resize","newWidth","newHeight","totalGridWidth","row","col","newBrick","getBricks","bloc","getElementById","window","innerWidth","innerHeight","gameUI","ballList","barre","handleResize","colGrid","rowGrid","newBrickWidth","newBrickHeight","gameLoop","clearRect","requestAnimationFrame"],"mappings":"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"}